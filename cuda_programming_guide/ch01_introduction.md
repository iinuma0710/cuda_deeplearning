# 1. イントロダクション

## 1.1. GPU を利用する利点

GPU (Graphical Processing Unit) は同程度の価格、消費電力の CPU と比べて、高いスループットとメモリ帯域を得られます。
多くのアプリケーションで GPU を用いることによって CPU よりも高速に実行可能となります。
FPGA のようなデバイスは、より省電力ではあるものの、GPU よりも柔軟性の面で劣ります。
このような処理能力の違いは、GPU と CPU が異なる設計思想に基づいていることに起因します。
CPU はスレッドと呼ばれる処理のシーケンスを高速に処理することには長けていますが、並列実行可能なスレッドはせいぜい数10程度です。
一方、何千ものスレッドを並列実行可能で、これによってシングルスレッドの処理性能の低さを補完し、高いスループットを実現しています。
GPU は並列計算に特化しているため、データのキャッシングやフロー制御よりもデータ処理に多くのトランジスタを割いています。
以下の図に CPU と GPU の比較を示しています。

<div align="center"><img src="../images/gpu-devotes-more-transistors-to-data-processing.png" width=500 /></div>

浮動小数点演算のようなデータ処理に多くのトランジスタを割くことは、並列演算において大きな利点があります。
メモリのアクセス遅延を避けるため、トランジスタの観点で計算コストの高い、大きなキャッシュを用意したり、複雑なフロー制御をしたりしなくても、演算でメモリのアクセス遅延を隠蔽できます。
一般的に、アプリケーションには並列的な箇所と直列的な箇所があり、システムは GPU と CPU を組み合わせて全体のパフォーマンスを最大化しています。
並列的な処理の多いアプリケーションは、GPU の並列処理の特製をおおいに利用することで、CPUより高いパフォーマンスが得られます。

## 1.2. CUDA: 汎用並列コンピューティング向けプロットフォームとプログラミングモデル

2006年11月、NVIDIA は CUDA を世に送り出しました。
CUDA は、NVIDIA の GPU で CPU よりも効率的に複雑な計算問題を解くための、汎用並列コンピューティングのプラットフォームとプログラミングモデルです。
CUDA では C++ を高級プログラミング言語として利用し、ソフトウェア環境を構築できます。

## 1.3. スケーラブルなプログラミングモデル

マルチコア CPU と多コア GPU の登場によって、プロセッサは並列システムが主流となりました。
3D グラフィックス・アプリケーションが、コア数が大きく異なるメニーコア GPU に対して透過的に並列性を拡張するように、プロセッサ・コア数の増加を利用して透過的に並列性を拡張するアプリケーション・ソフトウェアを開発することが課題となります。
CUDA の並列プログラミングモデルは、C 言語のような標準的なプログラミング言語に慣れ親しんだプログラマが、学習曲線を低いまま維持しつつ、この課題を克服するように設計されています。

CUDA では、階層的なスレッドグループ、共有メモリ、バリア同期という3つの重要な抽象化を、最小限の言語拡張で実現しています。
これらの抽象化によって、粒度の粗いデータ、タスク並列性に、粒度の高いデータ、スレッド並列性を入れ込むことができます。
また、ある問題をスレッドのブロックによって独立して並列に解くことのできる粗いサブ問題に分割し、各サブ課題をブロック内の全スレッドを用いて協調的に並列処理できるより細かい問題に分割することができるようになります。
このように問題を分解することで、各サブ問題を解く際にスレッドが協調して言語の表現力を維持すると同時に、自動的なスケーラビリティを実現しています。
実際、各スレッドブロックは、GPU 内の利用可能なマルチプロセッサのいずれかを、任意の順序で、同時、あるいは逐次的にスケジューリングすることができます。
これによって、コンパイルされた CUDA プログラムはマルチプロセッサの数によらず実行可能であり、実行時のシステムではマルチプロセッサの物理的な数を把握しておくだけでよくなります。

このスケーラブルなプログラミングモデルにより、GPU アーキテクチャは、マルチプロセッサとメモリパーティションの数を拡張するだけで、高性能な愛好家向けGeForce GPU、プロフェッショナル向け Quadro および Tesla コンピューティング製品から、安価なメインストリーム向け GeForce GPU まで、幅広い市場範囲に対応できます。

## 1.4. ドキュメントの構成

README.md 参照
